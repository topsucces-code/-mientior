/**
 * Customer Data Export Service
 */

import jsPDF from 'jspdf'
import ExcelJS from 'exceljs'
import { Readable } from 'stream'
import { getCustomer360View } from '@/lib/customer-360'
import { logAction } from '@/lib/audit-logger'
import { format } from 'date-fns'
import { ExportFormat, ExportQueryParams } from './export-validation'
import { ExportSizeExceededError, ExportGenerationError } from './export-errors'

export interface ExportMetadata {
  exportedBy: { id: string; name: string }
  exportedAt: Date
  customerId: string
  format: ExportFormat
  options?: ExportQueryParams
}

export interface ExportOptions extends ExportQueryParams {
  format: ExportFormat
}

/**
 * Generate customer export data by fetching complete 360 view
 */
export async function generateCustomerExportData(
  customerId: string,
  options: ExportOptions
) {
  const customerData = await getCustomer360View(customerId)
  
  // Filter data based on options
  if (!options.includeOrders) {
    delete customerData.orders
  }
  
  if (!options.includeAnalytics) {
    delete customerData.analytics
  }
  
  if (!options.includeNotes) {
    delete customerData.notes
  }
  
  if (!options.includeTags) {
    delete customerData.tags
  }
  
  return customerData
}

/**
 * Generate PDF report for customer data using jsPDF
 */
export async function generatePDFReport(
  customerId: string,
  metadata: ExportMetadata
): Promise<Buffer> {
  const customerData = await getCustomer360View(customerId)
  
  // Create new PDF document
  const doc = new jsPDF()
  let yPosition = 20
  
  // Header
  doc.setFontSize(20)
  doc.text('Customer 360 Report', 20, yPosition)
  yPosition += 15
  
  // Export metadata
  doc.setFontSize(10)
  doc.text(`Generated on: ${format(metadata.exportedAt, 'PPpp')}`, 20, yPosition)
  yPosition += 5
  doc.text(`Generated by: ${metadata.exportedBy.name}`, 20, yPosition)
  yPosition += 15
  
  // Customer Profile Section
  doc.setFontSize(16)
  doc.text('Customer Profile', 20, yPosition)
  yPosition += 10
  
  doc.setFontSize(10)
  doc.text(`ID: ${customerData.profile.id}`, 20, yPosition)
  yPosition += 5
  doc.text(`Name: ${customerData.profile.name}`, 20, yPosition)
  yPosition += 5
  doc.text(`Email: ${customerData.profile.email}`, 20, yPosition)
  yPosition += 5
  doc.text(`Phone: ${customerData.profile.phone || 'N/A'}`, 20, yPosition)
  yPosition += 5
  doc.text(`Registration Date: ${format(customerData.profile.registrationDate, 'PPP')}`, 20, yPosition)
  yPosition += 5
  doc.text(`Account Status: ${customerData.profile.accountStatus}`, 20, yPosition)
  yPosition += 5
  doc.text(`Loyalty Level: ${customerData.profile.loyaltyLevel || 'N/A'}`, 20, yPosition)
  yPosition += 15
  
  // Customer Metrics Section
  doc.setFontSize(16)
  doc.text('Customer Metrics', 20, yPosition)
  yPosition += 10
  
  doc.setFontSize(10)
  doc.text(`Lifetime Value: €${customerData.metrics.lifetimeValue.toFixed(2)}`, 20, yPosition)
  yPosition += 5
  doc.text(`Total Orders: ${customerData.metrics.totalOrders}`, 20, yPosition)
  yPosition += 5
  doc.text(`Average Order Value: €${customerData.metrics.averageOrderValue.toFixed(2)}`, 20, yPosition)
  yPosition += 5
  doc.text(`Total Spent: €${customerData.metrics.totalSpent.toFixed(2)}`, 20, yPosition)
  yPosition += 5
  doc.text(`Days Since Last Purchase: ${customerData.metrics.daysSinceLastPurchase}`, 20, yPosition)
  yPosition += 5
  doc.text(`Purchase Frequency: ${customerData.metrics.purchaseFrequency.toFixed(2)} orders/month`, 20, yPosition)
  yPosition += 5
  doc.text(`Customer Tenure: ${customerData.metrics.customerTenure} days`, 20, yPosition)
  yPosition += 15
  
  // Health Score Section
  doc.setFontSize(16)
  doc.text('Health Score', 20, yPosition)
  yPosition += 10
  
  doc.setFontSize(10)
  doc.text(`Overall Score: ${customerData.healthScore.score}/100 (${customerData.healthScore.level})`, 20, yPosition)
  yPosition += 5
  doc.text(`Purchase Score: ${customerData.healthScore.factors.purchase}/100`, 20, yPosition)
  yPosition += 5
  doc.text(`Engagement Score: ${customerData.healthScore.factors.engagement}/100`, 20, yPosition)
  yPosition += 5
  doc.text(`Support Score: ${customerData.healthScore.factors.support}/100`, 20, yPosition)
  yPosition += 5
  doc.text(`Recency Score: ${customerData.healthScore.factors.recency}/100`, 20, yPosition)
  yPosition += 15
  
  // Churn Risk Section
  doc.setFontSize(16)
  doc.text('Churn Risk Assessment', 20, yPosition)
  yPosition += 10
  
  doc.setFontSize(10)
  doc.text(`Risk Level: ${customerData.churnRisk.level.toUpperCase()}`, 20, yPosition)
  yPosition += 5
  doc.text(`Risk Score: ${customerData.churnRisk.score}/100`, 20, yPosition)
  yPosition += 5
  doc.text(`Days Since Last Purchase: ${customerData.churnRisk.factors.daysSinceLastPurchase}`, 20, yPosition)
  yPosition += 5
  doc.text(`Engagement Decline: ${customerData.churnRisk.factors.engagementDecline}%`, 20, yPosition)
  yPosition += 5
  doc.text(`Support Issues: ${customerData.churnRisk.factors.supportIssues}`, 20, yPosition)
  yPosition += 15
  
  // Segments Section
  if (customerData.segments && customerData.segments.length > 0) {
    doc.setFontSize(16)
    doc.text('Customer Segments', 20, yPosition)
    yPosition += 10
    
    doc.setFontSize(10)
    customerData.segments.forEach((segment) => {
      doc.text(`• ${segment.name}`, 20, yPosition)
      yPosition += 5
    })
    yPosition += 10
  }
  
  // Tags Section
  if (customerData.tags && customerData.tags.length > 0) {
    doc.setFontSize(16)
    doc.text('Customer Tags', 20, yPosition)
    yPosition += 10
    
    doc.setFontSize(10)
    const tagNames = customerData.tags.map(tag => tag.name).join(', ')
    doc.text(`Tags: ${tagNames}`, 20, yPosition)
    yPosition += 15
  }
  
  // Footer
  const pageHeight = doc.internal.pageSize.height
  doc.setFontSize(8)
  doc.text('Confidential - Customer 360 Report', 20, pageHeight - 10)
  doc.text(`Page 1 of 1`, 170, pageHeight - 10)
  
  // Log the export action
  await logAction({
    action: 'CUSTOMER_EXPORT',
    resource: 'customer',
    resourceId: customerId,
    adminUserId: metadata.exportedBy.id,
    metadata: { format: 'pdf', exportedAt: metadata.exportedAt },
  })
  
  // Return PDF as Buffer
  const pdfOutput = doc.output('arraybuffer')
  return Buffer.from(pdfOutput)
}

/**
 * Generate comprehensive CSV report for customer data
 */
export async function generateCSVReport(
  customerId: string,
  metadata: ExportMetadata
): Promise<string> {
  const customerData = await getCustomer360View(customerId)
  
  // Comprehensive CSV headers
  const headers = [
    'Export Timestamp',
    'Exported By',
    'Customer ID',
    'Name',
    'Email',
    'Phone',
    'Registration Date',
    'Account Status',
    'Loyalty Level',
    'Lifetime Value (EUR)',
    'Total Orders',
    'Average Order Value (EUR)',
    'Total Spent (EUR)',
    'Days Since Last Purchase',
    'Purchase Frequency (orders/month)',
    'Customer Tenure (days)',
    'Health Score',
    'Health Level',
    'Purchase Score',
    'Engagement Score',
    'Support Score',
    'Recency Score',
    'Churn Risk Level',
    'Churn Risk Score',
    'Churn Days Since Last Purchase',
    'Churn Engagement Decline (%)',
    'Churn Support Issues',
    'Customer Segments',
    'Customer Tags'
  ]
  
  // Prepare data row
  const row = [
    format(metadata.exportedAt, 'yyyy-MM-dd HH:mm:ss'),
    metadata.exportedBy.name,
    customerData.profile.id,
    `"${customerData.profile.name}"`, // Quote to handle commas in names
    customerData.profile.email,
    customerData.profile.phone || '',
    format(customerData.profile.registrationDate, 'yyyy-MM-dd'),
    customerData.profile.accountStatus,
    customerData.profile.loyaltyLevel || '',
    customerData.metrics.lifetimeValue.toFixed(2),
    customerData.metrics.totalOrders.toString(),
    customerData.metrics.averageOrderValue.toFixed(2),
    customerData.metrics.totalSpent.toFixed(2),
    customerData.metrics.daysSinceLastPurchase.toString(),
    customerData.metrics.purchaseFrequency.toFixed(2),
    customerData.metrics.customerTenure.toString(),
    customerData.healthScore.score.toString(),
    customerData.healthScore.level,
    customerData.healthScore.factors.purchase.toString(),
    customerData.healthScore.factors.engagement.toString(),
    customerData.healthScore.factors.support.toString(),
    customerData.healthScore.factors.recency.toString(),
    customerData.churnRisk.level,
    customerData.churnRisk.score.toString(),
    customerData.churnRisk.factors.daysSinceLastPurchase.toString(),
    customerData.churnRisk.factors.engagementDecline.toString(),
    customerData.churnRisk.factors.supportIssues.toString(),
    customerData.segments ? `"${customerData.segments.map(s => s.name).join(', ')}"` : '',
    customerData.tags ? `"${customerData.tags.map(t => t.name).join(', ')}"` : ''
  ]
  
  // Create CSV content
  const csvContent = [headers.join(','), row.join(',')].join('\n')
  
  // Log the export action
  await logAction({
    action: 'CUSTOMER_EXPORT',
    resource: 'customer',
    resourceId: customerId,
    adminUserId: metadata.exportedBy.id,
    metadata: { format: 'csv', exportedAt: metadata.exportedAt },
  })
  
  return csvContent
}

/**
 * Generate XLSX report for customer data
 */
export async function generateXLSXReport(
  customerId: string,
  metadata: ExportMetadata
): Promise<Buffer> {
  try {
    const customerData = await generateCustomerExportData(customerId, metadata.options || {
      format: 'xlsx',
      includeOrders: true,
      includeAnalytics: true,
      includeNotes: true,
      includeTags: true,
      dateRange: 'all',
      orderLimit: 100,
    })
    
    const workbook = new ExcelJS.Workbook()
    
    // Metadata
    workbook.creator = metadata.exportedBy.name
    workbook.created = metadata.exportedAt
    workbook.modified = metadata.exportedAt
    
    // Customer Profile Sheet
    const profileSheet = workbook.addWorksheet('Customer Profile')
    profileSheet.columns = [
      { header: 'Field', key: 'field', width: 25 },
      { header: 'Value', key: 'value', width: 40 },
    ]
    
    profileSheet.addRows([
      { field: 'Customer ID', value: customerData.profile.id },
      { field: 'Name', value: customerData.profile.name },
      { field: 'Email', value: customerData.profile.email },
      { field: 'Phone', value: customerData.profile.phone || 'N/A' },
      { field: 'Registration Date', value: format(customerData.profile.registrationDate, 'PPP') },
      { field: 'Account Status', value: customerData.profile.accountStatus },
      { field: 'Loyalty Level', value: customerData.profile.loyaltyLevel || 'N/A' },
    ])
    
    // Generate buffer
    const buffer = await workbook.xlsx.writeBuffer()
    
    // Log the export action
    await logAction({
      action: 'CUSTOMER_EXPORT',
      resource: 'customer',
      resourceId: customerId,
      adminUserId: metadata.exportedBy.id,
      metadata: { format: 'xlsx', exportedAt: metadata.exportedAt },
    })
    
    return Buffer.from(buffer)
  } catch (error) {
    throw new ExportGenerationError(`Failed to generate XLSX export: ${error}`)
  }
}

/**
 * Generate JSON report for customer data
 */
export async function generateJSONReport(
  customerId: string,
  metadata: ExportMetadata
): Promise<string> {
  try {
    const customerData = await generateCustomerExportData(customerId, metadata.options || {
      format: 'json',
      includeOrders: true,
      includeAnalytics: true,
      includeNotes: true,
      includeTags: true,
      dateRange: 'all',
      orderLimit: 100,
    })
    
    const exportData = {
      exportMetadata: {
        exportedBy: metadata.exportedBy,
        exportedAt: metadata.exportedAt,
        customerId: metadata.customerId,
        format: metadata.format,
      },
      customerData,
    }
    
    // Log the export action
    await logAction({
      action: 'CUSTOMER_EXPORT',
      resource: 'customer',
      resourceId: customerId,
      adminUserId: metadata.exportedBy.id,
      metadata: { format: 'json', exportedAt: metadata.exportedAt },
    })
    
    return JSON.stringify(exportData, null, 2)
  } catch (error) {
    throw new ExportGenerationError(`Failed to generate JSON export: ${error}`)
  }
}

/**
 * Create streaming CSV export for large datasets
 */
export function createStreamingCSVExport(
  customerId: string,
  metadata: ExportMetadata
): Readable {
  let headersSent = false
  
  const stream = new Readable({
    read() {
      // This will be called when the stream is ready for more data
    }
  })
  
  // Start the async export process
  ;(async () => {
    try {
      const customerData = await generateCustomerExportData(customerId, metadata.options || {
        format: 'csv',
        includeOrders: true,
        includeAnalytics: true,
        includeNotes: true,
        includeTags: true,
        dateRange: 'all',
        orderLimit: 100,
      })
      
      // Send headers first
      if (!headersSent) {
        const headers = [
          'Export Timestamp',
          'Exported By',
          'Customer ID',
          'Name',
          'Email',
          'Phone',
          'Registration Date',
          'Account Status',
          'Loyalty Level',
          'Lifetime Value (EUR)',
          'Total Orders',
          'Average Order Value (EUR)',
          'Total Spent (EUR)',
          'Days Since Last Purchase',
          'Purchase Frequency (orders/month)',
          'Customer Tenure (days)',
          'Health Score',
          'Health Level',
          'Churn Risk Level',
          'Churn Risk Score',
          'Customer Segments',
          'Customer Tags'
        ]
        
        stream.push(headers.join(',') + '\n')
        headersSent = true
      }
      
      // Send customer data row
      const row = [
        format(metadata.exportedAt, 'yyyy-MM-dd HH:mm:ss'),
        metadata.exportedBy.name,
        customerData.profile.id,
        `"${customerData.profile.name}"`,
        customerData.profile.email,
        customerData.profile.phone || '',
        format(customerData.profile.registrationDate, 'yyyy-MM-dd'),
        customerData.profile.accountStatus,
        customerData.profile.loyaltyLevel || '',
        customerData.metrics.lifetimeValue.toFixed(2),
        customerData.metrics.totalOrders.toString(),
        customerData.metrics.averageOrderValue.toFixed(2),
        customerData.metrics.totalSpent.toFixed(2),
        customerData.metrics.daysSinceLastPurchase.toString(),
        customerData.metrics.purchaseFrequency.toFixed(2),
        customerData.metrics.customerTenure.toString(),
        customerData.healthScore.score.toString(),
        customerData.healthScore.level,
        customerData.churnRisk.level,
        customerData.churnRisk.score.toString(),
        customerData.segments ? `"${customerData.segments.map(s => s.name).join(', ')}"` : '',
        customerData.tags ? `"${customerData.tags.map(t => t.name).join(', ')}"` : ''
      ]
      
      stream.push(row.join(',') + '\n')
      
      // End the stream
      stream.push(null)
      
      // Log the export action
      await logAction({
        action: 'CUSTOMER_EXPORT',
        resource: 'customer',
        resourceId: customerId,
        adminUserId: metadata.exportedBy.id,
        metadata: { format: 'csv', exportedAt: metadata.exportedAt, streaming: true },
      })
      
    } catch (error) {
      stream.emit('error', new ExportGenerationError(`Streaming CSV export failed: ${error}`))
    }
  })()
  
  return stream
}