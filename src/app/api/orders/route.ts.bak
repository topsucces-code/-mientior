/**
 * API endpoint for fetching user orders
 */

import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const _start = parseInt(searchParams.get('_start') || '0')
    const _end = parseInt(searchParams.get('_end') || '10')

    // TODO: Remplacer par vraie requête Prisma quand le model Order sera créé
    // const orders = await prisma.order.findMany({
    //   skip: _start,
    //   take: _end - _start,
    //   orderBy: { createdAt: 'desc' },
    // })
    
    // Mock data pour l'instant
    const orders: any[] = []

    return NextResponse.json(orders, {
      headers: {
        'X-Total-Count': '0',
      },
    })
  } catch (error) {
    console.error('Orders fetch error:', error)
    return NextResponse.json({ error: 'Failed to fetch orders' }, { status: 500 })
  }
}
      depth: 2,
    })

    // Transform to frontend Order type
    const orders: Order[] = result.docs.map((order: any) => ({
      id: order.id,
      orderNumber: order.orderNumber,
      userId: typeof order.userId === 'object' ? order.userId.id : order.userId,
      items: order.items?.map((item: any) => ({
        productId: typeof item.productId === 'object' ? item.productId.id : item.productId,
        productName: typeof item.productId === 'object' ? item.productId.name : '',
        productImage: typeof item.productId === 'object' && item.productId.images?.[0]
          ? (typeof item.productId.images[0].image === 'object'
            ? item.productId.images[0].image.url
            : '')
          : '',
        variant: item.variantId ? {
          size: item.size,
          color: item.color,
          sku: item.variantId,
        } : undefined,
        quantity: item.quantity,
        price: item.price,
        subtotal: item.price * item.quantity,
      })) || [],
      status: order.status?.toLowerCase() || 'pending',
      paymentStatus: order.paymentStatus?.toLowerCase() || 'pending',
      subtotal: order.subtotal || 0,
      shippingCost: order.shippingCost || 0,
      tax: order.tax || 0,
      discount: order.discount || 0,
      total: order.total || 0,
      shippingAddress: order.shippingAddress || {},
      billingAddress: order.billingAddress,
      trackingNumber: order.trackingNumber,
      estimatedDelivery: order.estimatedDelivery,
      createdAt: new Date(order.createdAt),
      updatedAt: new Date(order.updatedAt),
    }))

    const response: PaginatedResponse<Order> = {
      data: orders,
      totalCount: result.totalDocs,
      page: result.page || page,
      pageSize: result.limit || limit,
      hasMore: result.hasNextPage || false,
    }

    return NextResponse.json(response)
  } catch (error: any) {
    console.error('Orders fetch error:', error)

    if (error.message === 'Unauthorized') {
      return NextResponse.json({ error: 'Authentication required' }, { status: 401 })
    }

    return NextResponse.json(
      { error: 'Failed to fetch orders' },
      { status: 500 }
    )
  }
}

